## 引言

   > 类与实例

    类是对象的定义，而实例是"真正的实物"

   ```
   class myNewObjectType(bases):
        'define "
        class_suite
   ```
   `如果没有一个父类，或者如果所有子类化的基本类没有父类，这样就是创建了一个经典类。Python推荐尽可能使用新式类`
   ```
   实例化，但是没有使用NEW
   myFirstObject = myNewObjectType()
   ```
   - 类仅用作名称空间，把数据保存在变量中，对他们按名称空间进行分组，使得他们处于同样的关系空间
   > 方法

    我们改进类的方式之一就是给类添加功能。类的功能有一个更通俗的名称中方法。Python中，方法定义在类定义中，但只能被例所调用
  - 定义类（和方法）
  - 创建一个实例
  - 实例调用方法

   ```
      class myNewObjectType(object):
         def printFoo(self)
            print()
self参数，在所有的方法专用明中都存在。这个参数代表实例对象本身，当你用实例调用方法，由解释器悄悄地传递给方法的，所以，不需要自己传递self进来，因为它是自动传入
   ```
   > 创建一个类（类定义）
   ```
   class AddrBookEntry(object):
       def __init__(self, nm, ph):
        self.name = nm
        self.phone = ph
        print()
       def udatePhone(self,newph)
        self.phone = newph
        pirnt()
   ```
   > 创建实例（实例化）
   ```
   john=AddrBookEntry('John Doe','408-555-12212')#为John Doe创建实例
   ```
   > 访问实例属性
   ```
   john
   访问到的是内存地址
   john.name
   John Doe
   john.phone
   408-555-1212

   ```
   >方法调用
   ```
   john.updatePhone('415-555-1212')更新John的电话
   ```

   > 创建子类
    靠继承进来行子类化是创建和定制新类类型的一种方式，新的类将保持已存在类所有的特性，而不会改动原来类的定义。对于新类类型而言，这个新子类可以定制
    只属于它的特定功能。除了与父类或基类的关系，子类与通常的类没有任何区别，也像一般可以实例化。而子类声明提到了你父类
   ```
   class EmplAddrBookEntry(AddrBookEntry):
        def __init__(self,nm,ph,id,em):
            AddrBookEntry.__init__(self,nm,ph)
                self.empid = id
                self.email = em
        def updateEmail(self, newem):
            self.email = newem
            print(self.name)
   ```
        当一个类被派生出来，子类就继承了基类的属性
        如果需要，每个子类最好定义它自己的构造器，不然，基类的构造器也会被调用。

   > 使用子类
   ```
   john = EmplAddrBookEntry('John Doe','408-555-1212',42,'John@xxxx')
   ```

## 面向对象编程

    OOD 面向对象设计
    OOP 面对对象编程

   > 现实中问题

    如何确定类，类与实例的联系与区别

   > OOP 常用术语
   - 抽象/实现

    抽象指对现实世界问题和实体的本质表现、行为和特征建模，建立一个相关的子集，可以用于描绘程序的结构，从而实现这种模型
    抽象不仅包括这种模型的数据属性，还定义了这些数据的接口。对某种抽象的实现就是对此数据及与之相关接口的现实化。
    现在化这个过程对于客户程序应当是透明而是无关的

   - 封装/接口

    封装描述了对数据/信息进行隐藏的观念，对数据属性提供接口和访问函数。作为实现的一部分，客户端根本不需要知道在封装之后，数据属性是如何组织的。Python中，所有类属性都是公开的，但名字可能"混淆"了，以阻止未授权的访问，但仅此而已，再没有其他预防措施了。
    这就需要在设计时，对数据提供相应的接口，以免程序通过不规范的操作来存取封装的数据属性

   - 合成

     合成撤充了对类的描述，使得多个不同的类合成为一个大的类，来解决现实问题。一个类由其他组成，更小的组件也可能是其他的类，数据属性及行为，所有这些合在一起，彼此是"有一个"的关系
     这些组件要么通过联合关系组在一起，要么聚合在一起，封装的组件仅能通过定义好的接口来访问，对于客户程序来说是透明的

   - 派生/继承/继承结构

    派生描述了子类的创建，新类保留已民存类型中所有需要的数据和行为，但允许修改或者其他的自定义操作，都不会修改原类的定义
    继承描述了子类属性从祖先继承这样一种方式。
    继承结构表示多"代"派生，可以描述成一个"族谱"，连续的子类，与祖先都有关系

   - 泛化/特化

    泛化表示所有子类与其父类及祖先类有一样的特点，所以子类可以认为同祖先类"是一个"的关系，因为一个派生对象（实例）是祖先类的一个"例子"
    特化描述所有子类的自定义，也就是什么属性让它与其祖先类不同。

   - 多态

     多态指出了对象如何通过他们共同的属性和动作来操作及访问，而不需要考虑他们具体的类。
     多态表明了动态（运行时）绑定的存在，允许重载及运行时类型确定和验证

   - 自省/反射

    自省表示给予程序员某种能力来进行"手工类型检查"的工作，它也补称为反射。这个已性质展示了某对象是如何在运行期取得自身信息的。

   -


   >

   >

   >

   >


