## 什么是函数

  > 函数是对程序逻辑进行结构化或过程化的一种编程方法。能将整块代码巧妙地隔离成易于管理的小模块，把重复代码放到函数 而不是进行大量拷贝--这样既能节省空间，也有助于保持一致
   ```
   decalaration/definitation def foo(): print('bar')
   functoin object/refernce foo()
   function call/invocation foo()
   ```
  > 函数与过程

   两者都是可以被调用的实体，但是传统意义上的函数或者"黑盒"，可以不带任何输入参数，经过一定的处理，最后向调用者传回返回值。Python的过程就是函数，因为解释器会隐式地返回默认值None

  > 返回值与函数类型

   函数会向调用者返回一个值，而实际编程中大部分函数更接近过程，不显示地返回任何东西。把过程看待成函数的语言通常对于"什么都不返回"的函数设定了特殊的类型或者值的名字。这些函数在c中默认为"void"返回值，意思是没有值返回。在python中，对应的返回对象类型是none.

   ```
   def hello():
        print("hello world")
   res = hello()
   hello world
   res
   print res
   None
   ```

## 调用函数
  > 函数操作符
  - 同大多数语言相同，我们用()调用函数。
  > 关键字参数

    关键字参数的概念仅仅针对函数的调用。这种理念是让调用者通过函数调用中的参数名字来区分参数。这样规范允许参数缺失或者不按顺序，因为解释器能通过给出的关键字来匹配参数的值。

  ```
  def foo(x):
    foo_suite#
    标准调用foo(): foo(42), foo('bar') foo(y)
    关键字调用foo(): foo(x=42) foo(x='bar')
  ```
  ```
  def net_conn(host,port):
    net_conn_suite

   net_conn('kappa',8080)
   net_conn(port=8080,host='kappa')
  ```
  > 默认参数

    默认参数就是声明了默认值的参数。因为给参数赋了默认值，所以，在函数调时，不向该参数传入值也是允放的

  > 参数组

    Python 同样允许程序员执行一个没有显示定义参数的函数，相应的方法是通过一个元组或者字典作为参数组传递给函数
  >

## 创建函数

  > def语句
  ```
  def function_name(arguments):

  ```

  > 声明与定义的比较

    在某Python将两者视为一体，函数的子名由声明的标题行及随后的定义体组成

  > 前向引用

    Python不允许在函数未声明之前，对其进行引用或调用

   `错误的`
   ```
   def foo():
    bar()
   def bar():

   ```
   `正确的`
   ```
   def bar():
   def foo():
    bar()
   ```
  >函数属性


  > 内部/内嵌函数

    在函数内创建另外一个函数（对象）是完全佥的。这种函数函数叫作内部或者内嵌函数
    内部函数一个有趣的方面在于整个函数体都在外部函数的作用域之内

  > *函数（与方法）装饰器

    装饰器背后的主要动机源自Python面向对象编程。
    装饰器以@开头，接着是装饰器函数的名字和可选参数，紧跟着装饰器志明的是被修饰的函数和装饰函数的可选参数

   ```
   @decorator(dec_opt_args)
   def fun(func_opt_args):

   ```
    装饰器可以如函数调用一样"堆叠"起来
   ```
   @deco2
   @deco1
   ```
   - 有参数和无参数的装饰器
   - 什么是装饰器

    装饰器实际就是函数
    引入日志
    增加计时逻辑来检测性能
    给函数加入事务的能力

   - 修饰符举例
   ```
   11-8
   ```
## 传递函数

## Formal Auguments

   > 位置参数

    位置参数必须以在被调用函数中定义的准确顺序来传递。

  > 默认参数

## 条件表达式

## 传入参数

## 形参

## 变长参数

## 函数式编程

   > 匿名函数与lambda
   ```
   lambda[arg1[, arg2....argN]]:
   ```

   > 内建函数

    apply() - 已淘汰
    fiter()
    map(
    reduce()

   >

## 变量的作用域

   > 全局变量与局部变量
   - 声明适用的程序的范围被称为了声明的作用域。在一个过程中，如果名字在过程的声明之内，它的出现即为过程的局部变量
   - 全局变量的一个特征是除非被删除，琐则它们存活脚本运行结束，肯对于所有的函数，他们的值都是可以被访问的。
   - 局部变量，存放于栈中，暂时地存在，仅仅只依赖于定义他们的函数现阶段是否处于活动
   - 当一个函数调用出现，其局部变量就进入声明它们的作用域。一个新的局部变量为对象创建，一旦函数完成，框轲被释放，变量将会离开作用域。
   
   > global语句
    如果将全局变量的名字声明在一个函数内，全局变量的名字能被局部变量给覆盖掉。
   ```
   a = 100;
   def foo():
        global a
        a=200
        a=300
        print(a)
   foo()
   print(a)
   a=200
   a=200
   ```
   > `闭包`

    闭包将内部函数自己的代码和作用域及外部函数的作用结合起来。闭包的词法变量不属于全局名称空间域或者局部---而属于其他的名称空间
    闭包对安装计算、隐藏状态和在函数对象和作用中随意切换是有用的。以绝相对的方式，应用于获取数据库行和处理数据。回调就是函数，闭包也是函数

   - 简单的闭包例子
   - 复杂点闭包例子

   > 作用域和lambda

   > 变量作用和名称空间

   >

## 递归

    如果函数包含了对其自身的调用，该函数就是递归的。如果一个新的调用能在相同过程中较早的调用结束之前开始，那么该过程就是递归。


## 生成器