## **Construtor 构造类**

## 基于构造函数创建自定义类

> 在普通函数执行的基础上"new xxx()"，这样就不是普通函数执行了，而是构造函数执行，当前函数名称之为"类名"，接收的返回结果是当前类的一个实例

>  自已创建的类名，最好第一个单词首字大写

> 这种构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装，平时编写业务逻辑一般不这样处理

> 示例

    ``` javascript
    function F() {

    }
    var a = new F(); // F是类， a是类的一个实例
    var b = new F() // B也是F的一个实例，a和b是独立分开的，互不影响
    console.log(a)
    ==OUTPUT==
    f {}

    ```

- JS中创建值有两种方式

    + 字面量表达式
    + 构造函数模式

        ```
        var obj = {} //字面量表达式
        var obj = new Object{} //构造函数模式
        ```
     + 基本数据类型基于两种不同模式创建出来的值是不一样的

        1. 基本字面量方式创建出来的值是基本类型值
        2. 基于构造函数创建出来的值是引用类型
        ```
        var num1 =12
        var num2 = new Number(12)
        typeof(num1) //number
        typeof(num2) //object
        ```
        3. num2是数字类型的实例，num1也是数字类的实例，它只是JS表示数字的特殊方式之一。都可以使用数字类提供的属性和方法

 `不管哪一种方式创造出来的都是Object类的实例，而实例之间是独立分开的，所以var xxx={}这种模式就是JS中的单例模式`


- **构造函数执行机制**

    + 向普通函数执行一样，形成一个私有作用域（栈内存）
          私有变量:

          a.形参赋值

          b.变量提升
    + `构造函数执行独有` 在JS代码自上而下执行之前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不存储任何东西）并让函数中的执行主体（this)指向这个新的堆内存（this ===创建的对象）
    + 代码自上而下执行
        -  也就是开始创建的对象其实就是当前fn这个类的一个实例，我们让this指向这个实例，代码执行中的this.xxx=xxx都是给实例设置"私有属性"，最后浏览器会把默认创建的实例返回，供外面接收
        -  再次执行 new fn 就是把上面的操作克隆一份，会形成新的实例（新的内存地址）所以说实例是独立分开的
    + `构造函数独有`代码执行完成把之前创建的堆内地址返回（浏览器默认返回）





